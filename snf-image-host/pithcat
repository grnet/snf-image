#!/usr/bin/env python

# Copyright (C) 2011-2014 GRNET S.A.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

"""
A tool that connects to the Pithos backend and returns the size and contents
of a pithos object.

Since the backend does not have a "root" account we use the account given in
the URL as the user when connecting to the backend.
"""

from optparse import OptionParser, OptionGroup
from sys import exit, stdout, stderr
from os import environ
from binascii import hexlify, unhexlify
from collections import namedtuple
from pkg_resources import parse_version

try:
    from pithos.backends.modular import ModularBackend
    from pithos.backends.version import __version__ as pithos_backend_version
except ImportError:
    stderr.write("Pithos backend was not found.\n")
    exit(2)

SELECTABLE_BE_VER = "0.15.1"

note = """
NOTE: You can pass all arguments through environment variables instead of
the command line: Setting the environment variable PITHCAT_INPUX_XXX to
VALUE is equivalent to passing a '--xxx VALUE' argument.

Using the --db argument directly is dangerous, because it may
expose sensitive information in the output of 'ps'. Consider passing
the DB URI through the environment variable PITHOS_INPUT_DB instead.\n"""

OptionParser.format_epilog = lambda self, formattxt: self.epilog
parser = OptionParser(usage='%prog [options] <URL>', epilog=note)
if parse_version(pithos_backend_version) >= parse_version(SELECTABLE_BE_VER):
    backend_group = OptionGroup(
        parser, "Backend-specific Options",
        "The backend-specific options depend on the specific "
        "version of Pithos backend (package snf-pithos-backend) installed.\n"
        "(Currently-installed version: Pithos backend '%s')" %
        pithos_backend_version)
    backend_group.add_option('--backend', dest='backend', metavar='BACKEND',
                             help='Pithos backend storage type', default='nfs')
    backend_group.add_option('--rados-conf', dest='rconf', metavar='RCONF',
                             help='RADOS configuration file to use',
                             default=None)
    backend_group.add_option('--rados-maps', dest='rmaps', metavar='RMAPS',
                             help='RADOS pool which Pithos maps reside',
                             default='maps')
    backend_group.add_option('--rados-blocks', dest='rblocks',
                             metavar='RBLOCKS',
                             help='RADOS pool which Pithos blocks reside',
                             default='blocks')
    backend_group.add_option('--data', dest='data', metavar='DIR',
                             help='path to the directory where data are stored'
                             )
    parser.add_option_group(backend_group)
else:
    parser.add_option('--data', dest='data', metavar='DIR',
                      help='path to the directory where data are stored')

parser.add_option('-s', action='store_true', dest='size', default=False,
                  help='print file size and exit')
parser.add_option('--db', dest='db', metavar='URI',
                  help='SQLAlchemy URI of the database [DANGEROUS: Do not use,'
                  'see NOTE below]', default=None)

LocationURL = namedtuple('LocationURL', ['account', 'container', 'object'])
HashmapURL = namedtuple('HashmapURL', ['hash', 'size'])


def parse_url(url):
    if url.startswith('pithos://'):
        t = url.split('/', 4)
        assert len(t) == 5, "Invalid URL"
        return LocationURL(*t[2:5])
    elif url.startswith('pithosmap://'):
        t = url.split('/', 3)
        assert len(t) == 4, "Invalid URL"
        return HashmapURL(*t[2:4])
    else:
        raise Exception("Invalid URL")


def print_size(backend, url):
    """Writes object's size to stdout."""
    if type(url) is LocationURL:
        account, container, object = url
        meta = backend.get_object_meta(account, account, container, object,
                                       None)
        print meta['bytes']
    elif type(url) is HashmapURL:
        print url.size
    else:
        raise Exception("Invalid URL")


def print_data(backend, url):
    """Writes object's size to stdout."""

    if type(url) is LocationURL:
        account, container, object = url
        size, hashmap = backend.get_object_hashmap(account, account, container,
                                                   object)
    elif type(url) is HashmapURL:
        hashmap = [hexlify(x)
                   for x in backend.store.map_get(unhexlify(url.hash))]
        size = int(url.size)
    else:
        raise Exception("Invalid URL")

    for hash in hashmap:
        block = backend.get_block(hash)
        if len(block) > size:
            block = block[:size]
        stdout.write(block)
        size -= len(block)


def main():
    options, args = parser.parse_args()
    if len(args) != 1:
        parser.print_help()
        exit(1)

    url = parse_url(args[0])

    if not options.data and 'PITHCAT_INPUT_DATA' not in environ:
        stderr.write(
            "Pithos data directory path is missing.\n"
            "Use the PITHCAT_INPUT_DATA environmental variable (recommended) "
            "or the --data command line option to define it.\n")
        exit(1)

    data_path = environ['PITHCAT_INPUT_DATA'] if not options.data else \
        options.data

    if options.db is None and 'PITHCAT_INPUT_DB' not in environ and \
            type(url) is LocationURL:
        stderr.write(
            "Pithos database URI is missing.\n"
            "Use the PITHCAT_INPUT_DB environmental variable (recommended) "
            "or the --db command line option to define it.\n")
        exit(1)

    if type(url) is HashmapURL:
        db_uri = None
    else:
        db_uri = environ['PITHCAT_INPUT_DB'] if not options.db else options.db

    if parse_version(pithos_backend_version) >= \
       parse_version(SELECTABLE_BE_VER):
        backend_storage = environ['PITHCAT_BACKEND_STORAGE'] if not \
            options.backend else options.backend

        if options.rconf is None and 'PITHCAT_RADOS_CEPH_CONF' not in environ:
            stderr.write(
                "RADOS storage backend is selected but "
                "RADOS conf file is missing.\n"
                "Use the PITHCAT_RADOS_CEPH_CONF environmental variable "
                "or the --rados-conf command line option to define it.\n")
            exit(1)

        rados_ceph_conf = environ['PITHCAT_RADOS_CEPH_CONF'] if not \
            options.rconf else options.rconf
        rados_maps = environ['PITHCAT_RADOS_POOL_MAPS'] if not \
            options.rmaps else options.rmaps
        rados_blocks = environ['PITHCAT_RADOS_POOL_BLOCKS'] if not \
            options.rblocks else options.rblocks
        block_params = {'mappool': rados_maps, 'blockpool': rados_blocks}

        backend = ModularBackend(None,
                                 db_uri if type(url) is LocationURL else None,
                                 None,
                                 data_path, block_params=block_params,
                                 backend_storage=backend_storage,
                                 rados_ceph_conf=rados_ceph_conf)
    else:
        backend = ModularBackend(None,
                                 db_uri if type(url) is LocationURL else None,
                                 None,
                                 data_path)

    if options.size:
        print_size(backend, url)
    else:
        print_data(backend, url)

if __name__ == '__main__':
    main()

# vim: set sta sts=4 shiftwidth=4 sw=4 et ai :
