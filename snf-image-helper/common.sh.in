# Copyright (C) 2011-2016 GRNET S.A. and individual contributors
# Copyright (C) 2007, 2008, 2009 Google Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

PROGNAME=$(basename $0)

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin

# Programs
XMLSTARLET=xmlstarlet
TUNE2FS=tune2fs
RESIZE2FS=resize2fs
PARTED=parted
SFDISK=sfdisk
MKSWAP=mkswap
BLKID=blkid
BLOCKDEV=blockdev
SGDISK=sgdisk
GROWFS_UFS=growfs.ufs
DUMPFS_UFS=dumpfs.ufs
GROWFS_OPENBSD=growfs.openbsd
DUMPFS_OPENBSD=dumpfs.openbsd
DATE="date -u" # Time in UTC
EATMYDATA=eatmydata
MOUNT="mount -n"
HIVEXGET=hivexget
HIVEXREGEDIT=hivexregedit
BTRFS=btrfs
XFS_GROWFS=xfs_growfs
BASE64=base64
NTFSINFO=ntfsinfo
NTFSRESIZE=ntfsresize
NTFSFIX=ntfsfix
E2FSCK=e2fsck

CLEANUP=( )
ERRORS=( )
WARNINGS=( )

MSG_TYPE_TASK_START="TASK_START"
MSG_TYPE_TASK_END="TASK_END"

STDERR_LINE_SIZE=10


add_cleanup() {
    local cmd=""
    for arg; do cmd+=$(printf "%q " "$arg"); done
    CLEANUP+=("$cmd")
}

close_fd() {
    local fd=$1

    exec {fd}>&-
}

send_result_kvm() {
    echo "$@" > /dev/ttyS1
}

send_monitor_message_kvm() {
    echo "$@" > /dev/ttyS2
}

send_result_xen() {
    xenstore-write /local/domain/0/snf-image-helper/$DOMID "$*"
}

send_monitor_message_xen() {
    #Broadcast the message
    echo "$@" \
        | socat "STDIO" "UDP-DATAGRAM:${BROADCAST}:${MONITOR_PORT},broadcast"
}

start_debug_shell_kvm() {
    local dev="/dev/ttyS3"

    echo "Starting a debug shell on \`$dev'"
    echo "See Ganeti logs for /dev/pts/X device to use on host."
    bash <$dev >$dev 2>&1
    echo "Returned from debug shell, resuming..."
}

start_debug_shell_xen() {
    echo "Cannot start a debug shell on Xen. Feature not yet supported."
}

start_debug_shell() {
    start_debug_shell_${HYPERVISOR}
}

prepare_helper() {
	local cmdline item key val hypervisor domid

	read -a cmdline	 < /proc/cmdline
	for item in "${cmdline[@]}"; do
            key=$(cut -d= -f1 <<< "$item")
            val=$(cut -d= -f2 <<< "$item")
            if [ "$key" = "hypervisor" ]; then
                hypervisor="$val"
            fi
            if [ "$key" = "rules_dev" ]; then
                export RULES_DEV="$val"
            fi
            if [ "$key" = "helper_ip" ]; then
                export IP="$val"
                export NETWORK="$IP/24"
                export BROADCAST="${IP%.*}.255"
            fi
            if [ "$key" = "monitor_port" ]; then
                export MONITOR_PORT="$val"
            fi
	done

    case "$hypervisor" in
    kvm)
        HYPERVISOR=kvm
        ;;
    xen-hvm|xen-pvm)
        if [ -z "$IP" ]; then
            echo "ERROR: \`helper_ip' not defined or empty" >&2
            exit 1
        fi
        if [ -z "$MONITOR_PORT" ]; then
            echo "ERROR: \`monitor_port' not defined or empty" >&2
            exit 1
        fi
        $MOUNT -t xenfs xenfs /proc/xen
        ip addr add "$NETWORK" dev eth0
        ip link set eth0 up
        ip route add default dev eth0
        export DOMID=$(xenstore-read domid)
        HYPERVISOR=xen
        ;;
    *)
        echo "ERROR: Unknown hypervisor: \`$hypervisor'" >&2
        exit 1
        ;;
    esac

    export HYPERVISOR
}

task_init_as() {
    declare -A attr
    export TASKNAME="$PROGNAME"

    if check_yes_no SNF_IMAGE_PROPERTY_CLOUD_INIT; then
        export CLOUD_INIT_CONFNAME="98_snf-image-${TASKNAME}.cfg"
    fi

    trap task_cleanup EXIT
    report_task_start

    while (( "$#" )); do
        attr["$1"]=yes
        shift
    done

    if [ -n "${attr[excludable]}" ]; then
        check_if_excluded
    fi

    if [ -n "${attr[fs_resize_excludable]}" ]; then
        check_if_filesystem_resize_excluded
    fi

    if [ -n "${attr[mounted_excludable]}" ]; then
        check_if_mounted_excluded
    fi

    if [ -n "${attr[overwritable]}" ]; then
        check_if_overwritten
    fi
}

report_error() {
    msg=""
    if [ ${#ERRORS[*]} -eq 0 ]; then
        # No error message. Print stderr
        local lines stderr
        stderr="$(tail --lines=${STDERR_LINE_SIZE} "$STDERR_FILE")"
        lines=$(wc -l <<< "$stderr")
        msg="STDERR:${lines}:$stderr"
    else
        for line in "${ERRORS[@]}"; do
            msg+="ERROR:$line"$'\n'
        done
    fi

    send_monitor_message_${HYPERVISOR} "$msg"
}

log_error() {
    ERRORS+=("$*")

    send_result_${HYPERVISOR} "ERROR: $@"

    # Use return instead of exit. The set -x options will terminate the script
    # but will also trigger ERR traps if defined.
    return 1
}

warn() {
    echo "Warning: $@" >&2
    send_monitor_message_${HYPERVISOR} "WARNING: $@"
}

report_task_start() {
    send_monitor_message_${HYPERVISOR} "$MSG_TYPE_TASK_START:${PROGNAME:2}"
}

report_task_end() {
    send_monitor_message_${HYPERVISOR} "$MSG_TYPE_TASK_END:${PROGNAME:2}"
}

system_poweroff() {
    # Sync everything to disk and sleep for a second before powering off.
    # Do this to ensure data has hit the disk, since we are about to
    # kill the helper VM with a sysrq call.
    sync
    sleep 1

    while [ 1 ]; do
        # Credits to psomas@grnet.gr for this ...
        echo o > /proc/sysrq-trigger
        sleep 1
    done
}

get_base_distro() {
    local root_dir=$1

    if [ -d "$root_dir/etc/coreos" ]; then
        echo "coreos"
    elif [ -e "$root_dir/etc/debian_version" ]; then
        echo "debian"
    elif [ -e "$root_dir/etc/redhat-release" ]; then
        echo "redhat"
    elif [ -e "$root_dir/etc/slackware-version" ]; then
        echo "slackware"
    elif [ -e "$root_dir/etc/SuSE-release" ]; then
        echo "suse"
    elif [ -e "$root_dir/etc/gentoo-release" ]; then
        echo "gentoo"
    elif [ -e "$root_dir/etc/arch-release" ]; then
        echo "arch"
    elif [ -e "$root_dir/etc/freebsd-update.conf" ]; then
        echo "freebsd"
    elif [ -e "$root_dir/etc/release" ]; then
        if grep -i netbsd "$root_dir/etc/release" &> /dev/null; then
            echo "netbsd"
        else
            warn "Unknown Unix flavor."
        fi
    elif [ -e "$root_dir/etc/motd" ]; then
        if grep -i ^openbsd <(head -1 "$root_dir/etc/motd") &> /dev/null; then
            echo "openbsd"
        else
            warn "Unknown Unix flavor"
        fi
    else
        warn "Unknown base distro."
    fi
}

get_distro() {
    local root_dir distro
    root_dir=$1

    if [ -e "$root_dir/etc/debian_version" ]; then
        distro="debian"
        if [ -e ${root_dir}/etc/lsb-release ]; then
            ID=$(grep ^DISTRIB_ID= ${root_dir}/etc/lsb-release | cut -d= -f2)
            if [ "x$ID" = "xUbuntu" ]; then
                distro="ubuntu"
            fi
        fi
        echo "$distro"
    elif [ -e "$root_dir/etc/fedora-release" ]; then
        echo "fedora"
    elif [ -e "$root_dir/etc/centos-release" ]; then
        echo "centos"
    elif [ -e "$root_dir/etc/redhat-release" ]; then
        echo "redhat"
    elif [ -e "$root_dir/etc/slackware-version" ]; then
        echo "slackware"
    elif [ -e "$root_dir/etc/SuSE-release" ]; then
        echo "suse"
    elif [ -e "$root_dir/etc/gentoo-release" ]; then
        echo "gentoo"
    elif [ -e "$root_dir/etc/arch-release" ]; then
        echo "arch"
    elif [ -e "$root_dir/etc/freebsd-update.conf" ]; then
        echo "freebsd"
    elif [ -e "$root_dir/etc/release" ]; then
        if grep -in netbsd "$root_dir/etc/release" &> /dev/null; then
            echo "netbsd"
        else
            warn "Unknown Unix flavor"
        fi
    elif [ -e "$root_dir/etc/motd" ]; then
        if grep -i ^openbsd <(head -1 "$root_dir/etc/motd") &> /dev/null; then
            echo "openbsd"
        else
            warn "Unknown Unix flavor"
        fi
    else
        warn "Unknown distro."
    fi
}

get_networking_tool() {
    local root_dir distro tool
    root_dir=$1

    if check_yes_no SNF_IMAGE_PROPERTY_NM_NETWORKING; then
        tool="nm"
    else
        distro=$(get_base_distro "$root_dir")
        if [ "$distro" = debian ]; then
            tool=ifupdown
        elif [ "$distro" = redhat ]; then
            tool=ifcfg
        else
            tool=$distro
        fi
    fi

    echo "@networkingdir@/$tool.sh"
}

get_partition_table() {
    local dev output
    dev="$1"
    # If the partition table is GUID and the secondary GPT header is not at the
    # end of the disk, parted will raise an error and will also print a warning
    # about the "Last Usable LBA" entry of the header.
    if ! output="$("$PARTED" -s -m "$dev" unit s print \
                   | grep -E -v "^(Warning|Error): ")"; then
        log_error "Unable to read partition table for device \`${dev}'. The image seems corrupted."
    fi

    echo "$output"
}

get_partition_table_type() {
    local ptable dev field
    ptable="$1"

    dev="$(sed -n 2p <<< "$ptable")"
    IFS=':' read -ra field <<< "$dev"

    echo "${field[5]}"
}

get_partition_count() {
    local ptable="$1"

    expr $(echo "$ptable" | wc -l) - 2
}

get_partition_by_num() {
    local ptable="$1"
    local id="$2"

    grep "^$id:" <<< "$ptable"
}

get_last_partition() {
    local ptable="$1"

    echo "$ptable" | tail -1
}

is_extended_partition() {
    local dev="$1"
    local part_num="$2"

    id=$($SFDISK --force --print-id "$dev" "$part_num")
    if [ "$id" = "5" -o "$id" = "f" ]; then
        echo "yes"
    else
        echo "no"
    fi
}

get_extended_partition() {
    local ptable dev
    ptable="$1"
    dev="$(echo "$ptable" | sed -n 2p | cut -d':' -f1)"

    tail -n +3 <<< "$ptable" | while read line; do
        part_num=$(cut -d':' -f1 <<< "$line")
        if [ $(is_extended_partition "$dev" "$part_num") == "yes" ]; then
            echo "$line"
            return 0
        fi
    done
    echo ""
}

get_logical_partitions() {
    local ptable part_num
    ptable="$1"

    tail -n +3 <<< "$ptable" | while read line; do
        part_num=$(cut -d':' -f1 <<< "$line")
        if [ $part_num -ge 5 ]; then
            echo "$line"
        fi
    done

    return 0
}

get_last_primary_partition() {
    local ptable dev output
    ptable="$1"
    dev=$(echo "ptable" | sed -n 2p | cut -d':' -f1)

    for i in 4 3 2 1; do
        if output=$(grep "^$i:" <<< "$ptable"); then
            echo "$output"
            return 0
        fi
    done
    echo ""
}

get_partition_to_resize() {
    local dev table table_type last_part last_part_num extended last_primary \
        ext_num prim_num
    dev="$1"

    table=$(get_partition_table "$dev")
    if [ -z "$table" ]; then
        return 0
    fi

    if [ $(get_partition_count "$table") -eq 0 ]; then
        return 0
    fi

    table_type=$(get_partition_table_type "$table")
    last_part=$(get_last_partition "$table")
    last_part_num=$(cut -d: -f1 <<< "$last_part")

    if [ "$table_type" == "msdos" -a $last_part_num -gt 4 ]; then
        extended=$(get_extended_partition "$table")
        last_primary=$(get_last_primary_partition "$table")
        ext_num=$(cut -d: -f1 <<< "$extended")
        last_prim_num=$(cut -d: -f1 <<< "$last_primary")

        if [ "$ext_num" != "$last_prim_num" ]; then
            echo "$last_prim_num"
        else
            echo "$last_part_num"
        fi
    else
        echo "$last_part_num"
    fi
}

create_partition() {
    local device="$1"
    local part="$2"
    local ptype="$3"

    local fields=()
    IFS=":;" read -ra fields <<< "$part"
    local id="${fields[0]}"
    local start="${fields[1]}"
    local end="${fields[2]}"
    local size="${fields[3]}"
    local fs="${fields[4]}"
    local name="${fields[5]}"
    local flags="${fields[6]//,/ }"

    if [ "$ptype" = "primary" -o "$ptype" = "logical" -o "$ptype" = "extended" ]; then
        $PARTED -s -m -- $device mkpart "$ptype" $fs "$start" "$end"
        for flag in $flags; do
            $PARTED -s -m $device set "$id" "$flag" on
        done
    else
        # For GPT
        start=${start:0:${#start}-1} # remove the s at the end
        end=${end:0:${#end}-1} # remove the s at the end
        $SGDISK -a 1 -n "$id":"$start":"$end" -t "$id":"$ptype" -c "$id":"$name" "$device"
    fi
}

enlarge_partition() {
    local device part ptype new_end fields new_part table logical id
    device="$1"
    part="$2"
    ptype="$3"
    new_end="$4"

    if [ -z "$new_end" ]; then
        new_end=$(cut -d: -f 3 <<< "$(get_last_free_sector "$device")")
    fi

    fields=()
    IFS=":;" read -ra fields <<< "$part"
    fields[2]="$new_end"

    new_part=""
    for ((i = 0; i < ${#fields[*]}; i = i + 1)); do
        new_part="$new_part":"${fields[$i]}"
    done
    new_part=${new_part:1}

    # If this is an extended partition, removing it will also remove the
    # logical partitions it contains. We need to save them for later.
    if [ "$ptype" = "extended" ]; then
        table="$(get_partition_table "$device")"
        logical="$(get_logical_partitions "$table")"
    fi

    id=${fields[0]}

    # Newer versions of parted have a resizepart command that can be used to
    # extend a partition. If this command is absent, we will have to remove and
    # recreate a partition. This is not safe because there is no way to retain
    # the partition number if the numbering contains gaps. In order to
    # determine if parted supports resizepart we print the command's usage. If
    # the output is not empty, the command is there.
    supports_resizepart=$($PARTED -s -m "$device" help resizepart)

    if [ -n "$supports_resizepart" ]; then
        $PARTED -s -m -- "$device" resizepart "$id" "$new_end"
    else
        $PARTED -s -m "$device" rm "$id"
        create_partition "$device" "$new_part" "$ptype"

        if [ "$ptype" = "extended" ]; then
            # Recreate logical partitions
            echo "$logical" | while read logical_part; do
                create_partition "$device" "$logical_part" "logical"
            done
        fi
    fi
}

get_last_free_sector() {
    local dev unit last_line ptype
    dev="$1"
    unit="$2"

    if [ -n "$unit" ]; then
        unit="unit $unit"
    fi

    last_line="$($PARTED -s -m "$dev" "$unit" print free | tail -1)"
    ptype="$(cut -d: -f 5 <<< "$last_line")"

    if [ "$ptype" = "free;" ]; then
        echo "$last_line"
    fi
}

get_sysprepinf() {
    local target
    target="$1"

    # Return position of old-style (XP / Server 2003) answer file,
    # C:\SYSPREP\SYSPREP.INF, if found.
    sysprepinf="$target"/sysprep/sysprep.inf
    if [ ! -f "$sysprepinf" ]; then
        sysprepinf=""
    fi
    echo "$sysprepinf"
}

get_unattend() {
    local target
    target="$1"

    # TODO: Take into account the precise answer file search order defined in
    # https://technet.microsoft.com/en-us/library/cc749415(v=ws.10).aspx
    for unattend in "$target/unattend.xml" "$target/autounattend.xml"; do
        if [ -f "$unattend" ]; then
            echo "$unattend"
            break
        fi
    done
}

create_unattend_component() {
    local unattend pass component arch args settings component
    unattend="$1"
    pass="$2"
    name="$3"
    arch="$4"

    settings='/_:unattend/_:settings[@pass="'"$pass"'"]'

    # Create the 'settings' node if missing
    if ! $XMLSTARLET sel -t -v "$settings" "$unattend" &>/dev/null; then
        $XMLSTARLET ed -L -s '/_:unattend' -t elem -n settings -i \
            '/_:unattend/_:settings[not(@pass)]' -t attr -n pass -v "$pass" \
            "$unattend"
    fi

    component=$settings'/_:component[@name="'"$name"'" and @processorArchitecture="'"$arch"'"]'

    # Create the 'component' node if missing
    if ! $XMLSTARLET sel -t -v "$component" "$unattend" &>/dev/null; then
        $XMLSTARLET ed -L -s "$settings" -t elem -n component "$unattend"
        $XMLSTARLET ed -L -i "$settings"'/_:component[not(@name)]' -t attr \
            -n name -v "$name" "$unattend"
        $XMLSTARLET ed -L -i \
            "$settings"'/_:component[@name="'"$name"'" and not(@processorArchitecture)]' \
            -t attr -n processorArchitecture -v "$arch" "$unattend"
        $XMLSTARLET ed -L \
            -i "$component" -t attr -n publicKeyToken -v 31bf3856ad364e35 \
            -i "$component" -t attr -n language -v neutral \
            -i "$component" -t attr -n versionScope -v nonSxS \
            -i "$component" -t attr -n xmlns:wcm -v "http://schemas.microsoft.com/WMIConfig/2002/State" \
            -i "$component" -t attr -n xmlns:xsi -v "http://www.w3.org/2001/XMLSchema-instance" \
            "$unattend"
    fi

    echo "$component"
}

windows_add_synchronous_command() {
    local unattend arch description order path component run_synchronous \
        token rsc
    unattend="$1"
    arch="$2"
    description="$3"
    order="$4"
    path="$5"

    # Create 'Microsoft-Windows-Deployment' if missing
    component="$(create_unattend_component "$unattend" specialize 'Microsoft-Windows-Deployment' "$arch")"

    if ! $XMLSTARLET sel -t -v "$component/_:RunSynchronous" "$unattend" &>/dev/null; then
        $XMLSTARLET ed -L -s "$component" -t elem -n RunSynchronous "$unattend"
    fi

    token=$(cat /proc/sys/kernel/random/uuid)
    $XMLSTARLET ed -L -s "$component/_:RunSynchronous" -t elem -n RunSynchronousCommand "$unattend"
    $XMLSTARLET ed -L -s "($component/_:RunSynchronous/_:RunSynchronousCommand[count(@*)=0])[1]" -t attr -n randomToken -v "$token" "$unattend"

    rsc="$component/_:RunSynchronous/_:RunSynchronousCommand[@randomToken=\"$token\"]"
    $XMLSTARLET ed -L \
        -s "$rsc" -t elem -n Description -v "$description" \
        -s "$rsc" -t elem -n Order -v "$order" \
        -s "$rsc" -t elem -n Path -v "$path" \
        -i "$rsc" -t attr -n wcm:action -v add "$unattend"
    $XMLSTARLET ed -L -d "$rsc/@randomToken" "$unattend"
}

windows_update_unattend_node() {
    local unattend pass component arch name value xpath
    unattend="$1"
    pass=$2
    component=$3
    arch="$4"
    name="$5"
    value="$6"

    # Create component if missing
    xpath="$(create_unattend_component "$unattend" "$pass" "$component" "$arch")"

    if $XMLSTARLET sel -t -v "$xpath/_:$name" "$unattend" &> /dev/null; then
        # The node exists. Updating its value.
        $XMLSTARLET ed -L -u "$xpath/_:$name" -v "$value" "$unattend"
    else
        # Creating the node.
        $XMLSTARLET ed -L -s "$xpath" -t elem -n $name -v "$value" "$unattend"
    fi
}

bsd2linux() {
    local partition device
    partition="$1"
    device="$2"

    linux_part=$(@scriptsdir@/disklabel.py --get-partitions-mapping "$device" \
                 | grep ^"$partition": | cut -d" " -f2)

    if [[ "$linux_part" =~ ^[1-9][0-9]*$ ]]; then
        echo "$linux_part"
        return 0
    fi

    log_error "Couldn't find out mapping for BSD partition: \`$partition' in \`$device'"
}

cidr2mask() {
    local zeroes=$((32-$1))
    local shifts
    local IFS=.
    shift

    for i in 1 2 3 4; do
        ((shifts = zeroes > 8 ? 8 : zeroes))
        zeroes=$((zeroes - shifts))
        set $((255 >> shifts << shifts)) "$@"
    done
    echo "$*"
}

find_mount_target() {
    local device
    device="$1"

    while read entry; do
        set $entry
        if [ "$device" = "$1" -o "$device" = "$(readlink -f "$1")" ]; then
            echo "$2"
            break
        fi
    done <<< "$(cat /proc/mounts)"
}

mount_all() {
    local osfamily target fs device fstab entry duid opts types num
    osfamily="$1"
    device="$2"
    target="$3"

    case "$osfamily" in
    linux)
        fs="auto|ext[234]|msdos|vfat|ntfs|btrfs|xfs"
        ;;
    freebsd)
        fs="ufs|msdosfs|ntfs"
        ;;
    openbsd)
        fs="ffs|msdos|ntfs|ext2fs"
        ;;
    netbsd)
        fs="ffs|ufs|msdos|ext2fs|ntfs"
        ;;
    *)
        log_error "Unsupported osfamily: \`$osfamily'"
        ;;
    esac

    if [ ! -f "${target}/etc/fstab" ]; then
        warn "No \`/etc/fstab' found under \`${target}'!"
        return 0
    fi

    # Note: We swap the 2 first fstab entry fields to sort in accordance with mount points
    fstab="$(grep -v ^\# "${target}/etc/fstab" \
             | gawk "{ if (match(\$3, \"$fs\")) { print \$2,\$1,\$3 } }" \
             | sort -bd)"

    if [ -z "$fstab" ]; then
        warn "No useful entries where found in \`/etc/fstab'."
        return 0
    fi

    # entry=(<mpoint> <device> <fs>)
    while read -ra entry; do
        # Skip root. It is already mounted
        if [ "${entry[0]}" = "/" ]; then
            continue
        fi

        opts="rw"
        types="auto"

        if [ "$osfamily" = linux ]; then

            # Not sure if this is needed when allowing auto fs but it doesn't harm
            if [[ "${entry[1]}" =~ ^(none|proc|tmpfs)$ ]]; then
                warn "Skipping fstab entry: \`${entry[1]} ${entry[0]} ${entry[2]}'"
                continue
            fi

            # Skip floppies (the check is needed since we allow auto fs)
            if [[ "${entry[1]}" =~ ^/dev/(fd[0-9]|floppy) || \
                  "${entry[0]}" =~ ^/(mnt|media)/floppy ]]; then
                warn "Skipping fstab entry: \`${entry[1]} ${entry[0]} ${entry[2]}'"
                continue
            fi

            # Skip cdroms (the check is needed since we allow auto fs)
            if [[ "${entry[1]}" =~ ^/dev/cdrom || \
                  "${entry[0]}" =~ ^/(mnt|media)/cdrom ]]; then
                warn "Skipping fstab entry: \`${entry[1]} ${entry[0]} ${entry[2]}'"
                continue
            fi

           # Linux persistent block device naming
            if [[ ${entry[1]} =~ ^(LABEL|UUID)= ]]; then
                entry[1]=$(findfs "${entry[1]}")
            else
                log_error "fstab contains non-persistent block device name: " \
                    "\`${entry[1]}' for mount point: \`${entry[0]}'"
            fi
        else
            if [[ "$osfamily" =~ ^(open|net)bsd$ ]]; then
                # OpenBSD DUIDs device naming
                if [[ "${entry[1]}" =~ ^[a-f0-9]{16}\.[a-p]$ ]]; then
                    duid="$(@scriptsdir@/disklabel.py --get-duid "$device")"

                    if [[ ! "${entry[1]}" =~ ^$duid ]]; then
                        warn "fstab refers to unknown DUID: \`$duid'"
                        continue
                    fi
                fi
                num="$(disklabel2linux "${entry[1]: -1}")"
                if [ "${entry[2]}" = ffs -o "$entry[2]" = ufs ]; then
                    types="ufs"
                    opts="ufstype=44bsd,rw"
                fi
            else # FreeBSD
                # We do not support FreeBSD labels for now
                if [[ "${entry[1]}" =~ ^/dev/(ufs|label)/ ]]; then
                    log_error "fstab contains FreeBSD labels. We currently don't support them"
                fi
                num="${entry[1]: -1}"
                if [ "${entry[2]}" = ufs ]; then
                    types="ufs"
                    opts="ufstype=ufs2,rw"
                fi
            fi
            entry[1]="${device}${num}"
        fi

        $MOUNT -t "$types" -o "$opts" "${entry[1]}" "${target}${entry[0]}"
        # In many cases when you try to mount a UFS file system read-write, the
        # mount command returns SUCCESS and a message like this gets printed:
        #
        #   mount: warning: <target> seems to be mounted read-only.
        #
        # remounting does the trick
        if [ "$types" = ufs ]; then
            $MOUNT -o remount,rw "${entry[1]}"
        fi

    done <<< "$fstab"
}

umount_all() {
    local target mpoints
    target="$1"

    # Unmount file systems mounted under directory `target'
    mpoints="$({ gawk "{ if (match(\$2, \"^$target\")) { print \$2 } }" < /proc/mounts; } \
               | sort -rbd | uniq)"

    for mpoint in $mpoints; do
        umount $mpoint
    done
}

get_ufstype() {
    local device ufs pipefail

    device="$1"

    pipefail=$(set -o | grep pipefail | cut -f2)
    if [ "$pipefail" = on ]; then
        set +o pipefail
    fi
    ufs="$($DUMPFS_UFS "$device" | head -1 \
           | gawk -F "[()]" '{ for (i=2; i<NF; i+=2) print $i }')"
    if [ "$pipefail" = on ]; then
        set -o pipefail
    fi

    case "$ufs" in
        UFS1)
            echo 44bsd
            ;;
        UFS2)
            echo ufs2
            ;;
        *)
            log_error "Unsupported UFS type: \`$ufs' in device $device"
            echo ""
            ;;
    esac
}

get_windows_architecture() {
    local target hive current
    target="$1"

    hive="$target/windows/system32/config/system"

    current=$($HIVEXGET "$hive" Select Current)
    if [ "$current" = "" ]; then
        log_error "Unable to find CurrentControlSet in the registry"
    fi

    # Pad the value with zeros
    current=$(printf "%03d" "$current")

   $HIVEXGET "$hive" 'ControlSet'${current}'\Control\Session Manager\Environment' \
       | grep PROCESSOR_ARCHITECTURE \
       | cut -d= -f2 \
       | sed 's/"//g' \
       | tr [A-Z] [a-z]
}

get_windows_nt_version() {
    local target hive current_version
    target="$1"

    hive="$target/windows/system32/config/software"
    if [ ! -f "$hive" ]; then
        log_error "File: \`$hive' does not exist"
    fi

    current_version=$($HIVEXGET "$hive" 'Microsoft\Windows NT\CurrentVersion' \
                      | grep ^'"CurrentVersion"=')

    if [[ "$current_version" =~ \"CurrentVersion\"=\"([0-9]+)\.([0-9]+)\" ]]; then
        echo ${BASH_REMATCH[1]} ${BASH_REMATCH[2]}
    else
        log_error "Can't decode CurrentVersion registry key: $current_version"
    fi
}

check_windows_if_sysprepped() {
    local target state
    target="$1"

    # https://technet.microsoft.com/en-us/library/hh824815.aspx
    state=$($HIVEXGET "$target/windows/system32/config/software" \
            '\Microsoft\Windows\CurrentVersion\Setup\State')

    case "$(grep '^"ImageState"=' <<< "$state" | cut -d= -f2)" in
    \"IMAGE_STATE_COMPLETE\")
        log_error "Image is not sysprepped. Windows customization is only" \
            "supported for sysprepped images."
        ;;
    \"IMAGE_STATE_UNDEPLOYABLE\")
        log_error "Image is in an undeployable state. Setup seems corrupted."
        ;;
    \"IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE\")
        ;;
    \"IMAGE_STATE_GENERALIZE_RESEAL_TO_AUDIT\")
        ;;
    \"IMAGE_STATE_SPECIALIZE_RESEAL_TO_OOBE\")
        log_error "Customization is supported only for generalized images." \
            "You must run sysprep /generalize when creating the image."
        ;;
    \"IMAGE_STATE_SPECIALIZE_RESEAL_TO_AUDIT\")
        log_error "Customization is supported only for generalized images." \
            "You must run sysprep /generalize when creating the image."
        ;;
    *)
        log_error "Can't check if image is sysprepped. Unknown System State."
        ;;
    esac
}

check_windows-legacy_if_sysprepped() {
    local target setup
    target="$1"

    setup=$($HIVEXGET "$target/windows/system32/config/system" '\Setup')
    if ! grep '"SystemSetupInProgress"=dword:00000001' <<<"$setup" &>/dev/null; then
        log_error "Image is not sysprepped. Windows customization is only" \
            "supported for sysprepped images."
    fi

    if ! grep '"MiniSetupInProgress"=dword:00000001' <<<"$setup" &>/dev/null; then
        log_error "MiniSetup flag is not set in Sysprep. Windows" \
            "customization is only supported for sysprepped images with" \
            "MiniSetup enabled."
    fi
}

check_if_root() {
    local os fd device is_root args windows_fs linux_fs freebsd_fs netbsd_fs \
        openbsd_fs supported_fs major minor

    osfamily="$1"
    fs="$2"
    device="$3"

    windows_fs="(ntfs|ntfs-3g|vfat|msdos|fat|fuse|fuseblk)"
    linux_fs="(ext[234]|xfs|jfs|zfs|btrfs|reiserfs|reiser4)"
    freebsd_fs="(ufs|zfs)"
    netbsd_fs="(ufs|zfs)"
    openbsd_fs="ufs"

    supported_fs="${osfamily}_fs"

    if [ "$fs" = "" ]; then
        warn "Can't detect a file system on device: \`$device'"
        return 0
    fi

    if [[ ! "$fs" =~ ${!supported_fs} ]]; then
        warn "Ignoring device: \`$device' with file system: \`$fs' when checking for a $osfamily root"
        return 0
    fi

    if [ "$fs" = ufs ]; then
        args="-t ufs -o ufstype=$(get_ufstype "$device"),ro"
    elif $NTFSINFO -m "$device" &> /dev/null; then
        args="-t lowntfs-3g -o ignore_case,windows_names,norecover,ro"
    else
        args="-o ro"
    fi

    is_root=no
    $MOUNT "$device" "$SNF_IMAGE_TARGET" $args || {
        warn "Unable to mount: \`$device' with file system: \`$fs'"
        set -e
        return 0
    }
    case "$osfamily" in
        freebsd|linux)
            if [ -f "$SNF_IMAGE_TARGET/etc/fstab" ]; then
                is_root=yes
            fi
            ;;
        windows)
            if [ -d "$SNF_IMAGE_TARGET/windows/system32" ]; then
                read major minor <<<$(get_windows_nt_version "$SNF_IMAGE_TARGET")
                if [ $major -lt 6 ]; then
                    osfamily="windows-legacy"
                fi
                is_root=yes
            fi
            ;;
    esac
    umount "$SNF_IMAGE_TARGET"

    if [ "$is_root" = yes ]; then
        export DETECTED_OSFAMILY="$osfamily"
    fi
}

examine_msdos_partition() {
    local dev part
    dev="$1"
    part="$2"

    num=$(cut -f1 -d: <<< "$part")
    id=$($SFDISK --force --print-id "$dev" "$num") || true
    fs=$($BLKID -s TYPE -o value "$dev$num") || true

    case "$id" in
        a5)
            export DETECTED_OSFAMILY=freebsd
            ;;
        a6)
            export DETECTED_OSFAMILY=openbsd
            ;;
        a9)
            export DETECTED_OSFAMILY=netbsd
            ;;
        7) # looks like Windows
            check_if_root windows "$fs" "$dev$num"
            ;;
        83) # looks like Linux
            check_if_root linux "$fs" "$dev$num"
            ;;
    esac

    if [ -n "$DETECTED_OSFAMILY" ]; then
        export DETECTED_ROOT_PARTITION="$num"
    fi
}

examine_gpt_partition() {
    local dev part ufs_type
    dev="$1"
    part="$2"

    # It's OK if some of those fail
    num=$(cut -f1 -d: <<< "$part")
    fs=$($BLKID -s TYPE -o value "$dev$num") || true
    id=$($SGDISK -i "$num" "$dev" | \
         grep "^Partition GUID code:" | \
         cut -f2 -d: | \
         gawk '{print $1}') || true

    case "$id" in
        516E7CB6-6ECF-11D6-8FF8-00022D09712B) # FreeBSD
            check_if_root freebsd "$fs" "$dev$num"
            ;;
        EBD0A0A2-B9E5-4433-87C0-68B6B72699C7) # Windows
            check_if_root windows "$fs" "$dev$num"
            ;;
        *) # Linux does not respect the Partition GUID code at all
            check_if_root linux "$fs" "$dev$num"
            ;;
    esac

    if [ -n "$DETECTED_OSFAMILY" ]; then
        export DETECTED_ROOT_PARTITION="$num"
    fi
}

detect_image_properties() {
    local dev table
    dev="$1"

    table=$(get_partition_table "$dev")
    pttype=$(get_partition_table_type "$table")

    partitions=$(tail -n +3 <<< "$table")
    for part in $partitions; do
        "examine_${pttype}_partition" "$dev" "$part"
        if [ -n "$DETECTED_OSFAMILY" -a -n "$DETECTED_ROOT_PARTITION" ]; then
            break
        fi
    done
}

get_cloud_init_config() {
    local target cfg_d confname
    target="$1"
    confname="$2"

    for i in "" "local"; do
        cfg_d="$target/$i/etc/cloud/cloud.cfg.d"

        if [ -d "$cfg_d" ]; then
            echo "$cfg_d/$confname"
            return
        fi
    done

    log_error "Unable to find directory to host the cloud-init configuration"
}

encode_array() {
    local array_name cnt tmp
    array_name="$1"

    cnt=0
    tmp="${array_name}[@]"
    for i in "${!tmp}"; do
        declare -g ${array_name}_$cnt=$i
        : $((cnt++))
    done

    declare -g ${array_name}_COUNT=$cnt
}

cleanup() {
    # if something fails here, it shouldn't call cleanup again...
    trap - EXIT

    if [ ${#CLEANUP[*]} -gt 0 ]; then
        LAST_ELEMENT=$((${#CLEANUP[*]}-1))
        REVERSE_INDEXES=$(seq ${LAST_ELEMENT} -1 0)
        for i in $REVERSE_INDEXES; do
            # If something fails here, it's better to retry it for a few times
            # before we give up with an error. This is needed for kpartx when
            # dealing with NTFS partitions mounted through fuse. umount is not
            # synchronous and may return while the partition is still busy. A
            # premature attempt to delete partition mappings through kpartx on
            # a device that hosts previously mounted NTFS partition may fail
            # with a `device-mapper: remove ioctl failed: Device or resource
            # busy' error. A sensible workaround for this is to wait for a
            # while and then try again.
            local cmd=${CLEANUP[$i]}
            $cmd || for interval in 0.25 0.5 1 2 4; do
            echo "Command $cmd failed!"
            echo "I'll wait for $interval secs and will retry..."
            sleep $interval
            $cmd && break
        done
	if [ "$?" != "0" ]; then
            echo "Giving Up..."
            exit 1;
        fi
    done
  fi
}

task_cleanup() {
    local rc=$?

    if [ $rc -eq 0 ]; then
       report_task_end
    else
       report_error
       # If in debug mode, drop to a shell and let a developer figure it out
       if grep -q snf_image_debug_helper /proc/cmdline; then
           echo "Failed. In debug mode, dropping to a shell."
           start_debug_shell
       fi
    fi
    cleanup
}

check_yes_no() {
    local name value
    name="${1}"

    if [ -z "${!name+dummy}" ]; then
        # variable is not defined at all
        return 1
    fi


    # lowercase value
    value="${!name,,}"

    # Remove the SNF_IMAGE_PROPERTY_ prefix from the name when displaying it.
    name="${name#SNF_IMAGE_PROPERTY_}"

    if [[ "$value" =~ ^(yes|true|on|1|set)$ ]]; then
        return 0
    elif  [[ "$value" =~ ^(no|false|off|0|unset)$ ]]; then
        return 1
    elif [ -z "$value" ]; then
        warn "Variable \`$name' defined but empty. Will treat this as a \`NO'"
        return 1
    else
        warn "Invalid value for variable: \`$name' (=$value). Will treat this as a \`YES'"
        return 0
    fi
}

check_if_excluded() {
    local name exclude
    name="$(tr [a-z] [A-Z] <<< ${PROGNAME:2})"
    exclude="SNF_IMAGE_PROPERTY_EXCLUDE_TASK_${name}"
    if check_yes_no "$exclude"; then
        warn "Task ${PROGNAME:2} was excluded and will not run."
        exit 0
    fi

    return 0
}

check_if_mounted_excluded() {
    if check_yes_no SNF_IMAGE_PROPERTY_EXCLUDE_MOUNTED_TASKS; then
        warn "Task ${PROGNAME:2} was excluded and will not run."
        exit 0
    fi

    return 0
}

check_if_filesystem_resize_excluded() {
    if check_yes_no SNF_IMAGE_PROPERTY_EXCLUDE_FILESYSTEMRESIZE_TASKS; then
        warn "Task ${PROGNAME:2} was excluded and will not run."
        exit 0
    fi

    return 0
}

check_if_overwritten() {
    local script ret

    if [ ! -d "$SNF_IMAGE_TARGET" ]; then
        log_error "Target dir: \`$SNF_IMAGE_TARGET' is missing."
    fi

    if ! check_yes_no SNF_IMAGE_PROPERTY_ALLOW_MOUNTED_TASK_OVERWRITING; then
        return 0
    fi

    script=$(find -L $SNF_IMAGE_TARGET/root/snf-image/helper \
             -iname "overwrite_task_${PROGNAME:2}" -type f 2>/dev/null) || true
    if [ -x "$script" ]; then
        warn "Task ${PROGNAME:2} was overwritten by file: \`${script:${#SNF_IMAGE_TARGET}}'"
        export OVERWRITTEN_TASK="$script"
        set +e
        $OVERWRITTEN_TASK "pre-exec"
        ret=$?
        set -e
        if [ $ret -eq 101 ]; then
            # Reserve 101 for the case where the original task should be
            # executed after the task that overwrote it has finished
            warn "Running task ${PROGNAME:2} after \`${script:${#SNF_IMAGE_TARGET}}' returned 101"

            # Overwrite exit to make sure the script is executed again at the
            # end. This is error-prone, since you'll always have to use exit on
            # normal termination (which we actually did before this) but I
            # couldn't think of a better way. Adding it in the task_cleanup()
            # is not an option because you can't control the failures well.
            exit() {
                local rc=$1
                if [ $rc -eq 0 ]; then
                    warn "Running \`${OVERWRITTEN_TASK:${#SNF_IMAGE_TARGET}}' again after task ${PROGNAME:2}"
                    $OVERWRITTEN_TASK "post-exec"
                fi
                builtin exit $rc
            }
        else
            exit $ret
        fi
    fi
}

return_success() {
    send_result_${HYPERVISOR} "SUCCESS"
}

networking_opts() {
    local usage="$0 [-i | -f | -n  <index>] [-4 (dhcp|static)] [-6 (dhcp|slaac|slaac_dhcp)]"
    ipv4=none
    ipv6=none
    index=
    initialize=no
    finalize=no

    while getopts "hifn:4:6:" opt; do
        case "$opt" in
        h)  echo $usage >&2
            exit 0
            ;;
        i)  initialize=yes
            ;;
        f)  finalize=yes
            ;;
        n)  index=$OPTARG
            ;;
        4)  ipv4=$OPTARG
            ;;
        6)  ipv6=$OPTARG
            ;;
        \?) exit 1
            ;;
        esac
    done

    shift $((OPTIND - 1))
    if [ $# -ne 0 ]; then
        log_error "Unknown arguments: $@" >&2
        exit 1
    fi

    if [ -z "$index" -a "$initialize" = no -a "$finalize" = no ]; then
        log_error "Either -i, -f or -n must be specified"
    fi

    if [ "$initialize" = yes -a "$finalize" = yes ]; then
        log_error "-i and -f should not be both specified"
    fi

    if [[ "$index" && ("$initialize" == yes || "$finalize" == yes) ]]; then
        log_error "-n cannot be combined with -i or -f"
    fi

    if [[ ! "$ipv4" =~ (dhcp|static|none) ]]; then
        log_error "invalid ipv4: $ipv4"
    fi

    if [[ ! "$ipv6" =~ (dhcp|slaac|slaac_dhcp|none) ]]; then
        log_error "invalid ipv6: $ipv6"
    fi

    if [[ (! "$index" =~ ^[0-9]+$) && "$prepare" = no ]]; then
        log_error "invalid index: $index"
    fi
}

check_windows_computer_name() {
    local name length msg matched pipefail

    name="${1}"
    length=$(wc -c <<< "$name")

    # ComputerName restrictions are documented here:
    #   https://technet.microsoft.com/en-us/library/ff715676.aspx

    msg="Invalid Windows ComputerName: \`$name'."

    # Check if the length of the string exceeds the 15 bytes
    if [ $length -gt 15 ]; then
        log_error "$msg It's size is bigger (=$length) than 15 bytes."
    fi

    pipefail=$(set -o | grep pipefail | gawk '{ print $2 }')
    set -o pipefail
    set +e
    # We only check for invalid ascii characters but this is OK. The name
    # derives from the instance's name and Ganeti seems to only allows ascii
    # characters for instance names.
    invalid_char="$(grep -o -P \
        '[\x00-\x2c\x2e-\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\x7e]' <<< "$name" \
        | head -1)"
    # If grep fails, the pipefail option will make $matched host the return
    # code of grep
    matched=$?
    set -e
    if [ "$pipefail" = off ]; then
        set +o pipefail
    fi

    if [ $matched -eq 0 ]; then
        log_error "$msg Contains invalid character: \`$(printf "%q" "$invalid_char")'."
    fi

    if [[ "$name" =~ ^([0-9])+$ ]]; then
        log_error "$msg Contains only numbers (0-9)."
    fi
}

trap cleanup EXIT
set -o pipefail

STDERR_FILE=$(mktemp)
add_cleanup rm -f "$STDERR_FILE"
exec 2> >(tee -a "$STDERR_FILE" >&2)

# vim: set sta sts=4 shiftwidth=4 sw=4 et ai :
